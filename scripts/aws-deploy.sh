#!/bin/bash
#
# Unified AWS deployment script for otlp2pipeline
#
# This script handles the complete deployment lifecycle:
# - S3 Tables + Lake Formation setup (Phase 0)
# - CloudFormation Phase 1 (table bucket, namespace, table, IAM role)
# - LakeFormation permissions grant
# - CloudFormation Phase 2 (Firehose delivery stream)
#
# Prerequisites:
# - AWS CLI configured with credentials
# - Caller must have IAM and LakeFormation admin permissions
# - CloudFormation template generated by: otlp2pipeline aws create --output template.yaml
#
# Usage:
#   ./scripts/aws-deploy.sh <template> --env <env> [--region <region>] [--namespace <ns>]
#   ./scripts/aws-deploy.sh status --env <env> [--region <region>]
#   ./scripts/aws-deploy.sh destroy --env <env> [--region <region>] [--force]
#
# Examples:
#   ./scripts/aws-deploy.sh template.yaml --env prod
#   ./scripts/aws-deploy.sh template.yaml --env prod --region us-west-2
#   ./scripts/aws-deploy.sh status --env prod
#   ./scripts/aws-deploy.sh destroy --env prod --force
#
# Naming:
#   --env prod  →  stack: otlp2pipeline-prod, bucket: otlp2pipeline-prod
#

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

# Symbols
CHECK="${GREEN}✓${NC}"
CROSS="${RED}✗${NC}"
ARROW="${YELLOW}→${NC}"

# Defaults
REGION="us-east-1"
NAMESPACE="default"
ROLE_NAME="S3TablesRoleForLakeFormation"
FORCE=false
ENV=""

# Parse arguments
COMMAND=""
TEMPLATE=""
POSITIONAL=()

while [[ $# -gt 0 ]]; do
    case $1 in
        status|destroy)
            COMMAND="$1"
            shift
            ;;
        --env)
            ENV="$2"
            shift 2
            ;;
        --region)
            REGION="$2"
            shift 2
            ;;
        --namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --help|-h)
            echo "Usage:"
            echo "  $0 <template.yaml> --env <env> [--region <region>] [--namespace <ns>]"
            echo "  $0 status --env <env> [--region <region>]"
            echo "  $0 destroy --env <env> [--region <region>] [--force]"
            echo ""
            echo "Commands:"
            echo "  (default)  Deploy all infrastructure (idempotent)"
            echo "  status     Check current deployment status"
            echo "  destroy    Tear down all infrastructure"
            echo ""
            echo "Options:"
            echo "  --env        Environment name (required) - derives stack and bucket names"
            echo "  --region     AWS region (default: us-east-1)"
            echo "  --namespace  S3 Tables namespace (default: default)"
            echo "  --force      Skip confirmation for destroy"
            echo ""
            echo "Naming convention:"
            echo "  --env prod  →  stack: otlp2pipeline-prod, bucket: otlp2pipeline-prod"
            exit 0
            ;;
        -*)
            echo "Unknown option: $1"
            exit 1
            ;;
        *)
            POSITIONAL+=("$1")
            shift
            ;;
    esac
done

# Handle positional arguments
if [ ${#POSITIONAL[@]} -gt 0 ]; then
    if [ -z "$COMMAND" ]; then
        TEMPLATE="${POSITIONAL[0]}"
    fi
fi

# Validate required arguments
if [ -z "$ENV" ]; then
    echo "Error: --env is required"
    exit 1
fi

# Normalize env name (strip otlp2pipeline- prefix if present)
ENV="${ENV#otlp2pipeline-}"

# Derive stack and bucket names from env
STACK="otlp2pipeline-${ENV}"
BUCKET="otlp2pipeline-${ENV}"

# Get AWS account info
get_account_info() {
    ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text 2>/dev/null) || {
        echo -e "${CROSS} Failed to get AWS account info. Check your credentials."
        exit 1
    }
    CALLER_ARN=$(aws sts get-caller-identity --query Arn --output text)
}

# Policy documents for S3 Tables role
TRUST_POLICY='{
    "Version": "2012-10-17",
    "Statement": [{
        "Effect": "Allow",
        "Principal": {"Service": "lakeformation.amazonaws.com"},
        "Action": ["sts:AssumeRole", "sts:SetSourceIdentity", "sts:SetContext"]
    }]
}'

S3_TABLES_POLICY='{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "LakeFormationPermissionsForS3ListTableBucket",
            "Effect": "Allow",
            "Action": ["s3tables:ListTableBuckets"],
            "Resource": ["*"]
        },
        {
            "Sid": "LakeFormationDataAccessPermissionsForS3TableBucket",
            "Effect": "Allow",
            "Action": [
                "s3tables:CreateTableBucket",
                "s3tables:GetTableBucket",
                "s3tables:CreateNamespace",
                "s3tables:GetNamespace",
                "s3tables:ListNamespaces",
                "s3tables:DeleteNamespace",
                "s3tables:DeleteTableBucket",
                "s3tables:CreateTable",
                "s3tables:DeleteTable",
                "s3tables:GetTable",
                "s3tables:ListTables",
                "s3tables:RenameTable",
                "s3tables:UpdateTableMetadataLocation",
                "s3tables:GetTableMetadataLocation",
                "s3tables:GetTableData",
                "s3tables:PutTableData"
            ],
            "Resource": ["*"]
        }
    ]
}'

# ============================================================================
# Status checks
# ============================================================================

check_iam_role() {
    aws iam get-role --role-name "${ROLE_NAME}" >/dev/null 2>&1
}

check_lakeformation_admin() {
    local admins
    admins=$(aws lakeformation get-data-lake-settings --region "${REGION}" \
        --query 'DataLakeSettings.DataLakeAdmins[*].DataLakePrincipalIdentifier' \
        --output text 2>/dev/null) || return 1
    echo "$admins" | grep -q "${CALLER_ARN}"
}

check_lakeformation_resource() {
    local resource_arn="arn:aws:s3tables:${REGION}:${ACCOUNT_ID}:bucket/*"
    aws lakeformation describe-resource --resource-arn "${resource_arn}" --region "${REGION}" >/dev/null 2>&1
}

check_glue_catalog() {
    aws glue get-catalog --catalog-id "s3tablescatalog" --region "${REGION}" >/dev/null 2>&1
}

check_stack_exists() {
    aws cloudformation describe-stacks --stack-name "${STACK}" --region "${REGION}" >/dev/null 2>&1
}

get_stack_phase() {
    local phase
    phase=$(aws cloudformation describe-stacks --stack-name "${STACK}" --region "${REGION}" \
        --query 'Stacks[0].Parameters[?ParameterKey==`Phase`].ParameterValue' \
        --output text 2>/dev/null)
    echo "${phase:-0}"
}

get_stack_status() {
    aws cloudformation describe-stacks --stack-name "${STACK}" --region "${REGION}" \
        --query 'Stacks[0].StackStatus' --output text 2>/dev/null
}

get_firehose_role_arn() {
    aws cloudformation describe-stacks --stack-name "${STACK}" --region "${REGION}" \
        --query 'Stacks[0].Outputs[?OutputKey==`FirehoseRoleARN`].OutputValue' \
        --output text 2>/dev/null
}

check_lakeformation_db_permission() {
    local role_arn="$1"
    aws lakeformation list-permissions \
        --principal "{\"DataLakePrincipalIdentifier\":\"${role_arn}\"}" \
        --resource "{\"Database\":{\"CatalogId\":\"${ACCOUNT_ID}:s3tablescatalog/${BUCKET}\",\"Name\":\"${NAMESPACE}\"}}" \
        --region "${REGION}" \
        --query 'PrincipalResourcePermissions[0]' \
        --output text 2>/dev/null | grep -q DESCRIBE
}

check_lakeformation_table_permission() {
    local role_arn="$1"
    local table_name="$2"
    aws lakeformation list-permissions \
        --principal "{\"DataLakePrincipalIdentifier\":\"${role_arn}\"}" \
        --resource "{\"Table\":{\"CatalogId\":\"${ACCOUNT_ID}:s3tablescatalog/${BUCKET}\",\"DatabaseName\":\"${NAMESPACE}\",\"Name\":\"${table_name}\"}}" \
        --region "${REGION}" \
        --query 'PrincipalResourcePermissions[0]' \
        --output text 2>/dev/null | grep -q ALL
}

# ============================================================================
# Status command
# ============================================================================

cmd_status() {
    echo "Checking deployment status..."
    echo ""
    get_account_info
    echo "Account: ${ACCOUNT_ID}"
    echo "Region:  ${REGION}"
    echo "Stack:   ${STACK}"
    echo "Bucket:  ${BUCKET}"
    echo ""

    echo "S3 Tables Setup:"
    if check_iam_role; then
        echo -e "  ${CHECK} IAM Role: ${ROLE_NAME}"
    else
        echo -e "  ${CROSS} IAM Role: ${ROLE_NAME} (not found)"
    fi

    if check_lakeformation_admin; then
        echo -e "  ${CHECK} LakeFormation Admin: ${CALLER_ARN}"
    else
        echo -e "  ${CROSS} LakeFormation Admin: not configured"
    fi

    if check_lakeformation_resource; then
        echo -e "  ${CHECK} LakeFormation Resource: registered"
    else
        echo -e "  ${CROSS} LakeFormation Resource: not registered"
    fi

    if check_glue_catalog; then
        echo -e "  ${CHECK} Glue Catalog: s3tablescatalog"
    else
        echo -e "  ${CROSS} Glue Catalog: s3tablescatalog (not found)"
    fi

    echo ""
    echo "CloudFormation Stack: ${STACK}"
    if check_stack_exists; then
        local status phase
        status=$(get_stack_status)
        phase=$(get_stack_phase)
        echo -e "  ${CHECK} Status: ${status}"
        echo -e "  ${CHECK} Phase: ${phase}"

        local role_arn
        role_arn=$(get_firehose_role_arn)
        if [ -n "$role_arn" ] && [ "$role_arn" != "None" ]; then
            echo ""
            echo "LakeFormation Grants:"
            if check_lakeformation_db_permission "$role_arn"; then
                echo -e "  ${CHECK} DESCRIBE on database '${NAMESPACE}'"
            else
                echo -e "  ${CROSS} DESCRIBE on database '${NAMESPACE}' (not granted)"
            fi

            if check_lakeformation_table_permission "$role_arn" "logs"; then
                echo -e "  ${CHECK} ALL on table 'logs'"
            else
                echo -e "  ${CROSS} ALL on table 'logs' (not granted)"
            fi

            if check_lakeformation_table_permission "$role_arn" "traces"; then
                echo -e "  ${CHECK} ALL on table 'traces'"
            else
                echo -e "  ${CROSS} ALL on table 'traces' (not granted)"
            fi
        fi

        if [ "$phase" = "2" ]; then
            echo ""
            echo -e "${CHECK} Deployment complete! Firehose is ready to receive data."
        elif [ "$phase" = "1" ]; then
            echo ""
            echo -e "${ARROW} Phase 1 complete. Run deploy again to complete Phase 2."
        fi
    else
        echo -e "  ${CROSS} Stack does not exist"
    fi
}

# ============================================================================
# Deploy command
# ============================================================================

setup_s3_tables() {
    echo ""
    echo "==> Phase 0: S3 Tables + Lake Formation Setup"

    # Step 1: IAM Role
    echo ""
    echo -e "${ARROW} Creating/updating IAM role: ${ROLE_NAME}"
    if check_iam_role; then
        echo "    Role exists, updating policies..."
        aws iam update-assume-role-policy \
            --role-name "${ROLE_NAME}" \
            --policy-document "${TRUST_POLICY}" >/dev/null
    else
        echo "    Creating role..."
        aws iam create-role \
            --role-name "${ROLE_NAME}" \
            --assume-role-policy-document "${TRUST_POLICY}" \
            --region "${REGION}" >/dev/null
        echo "    Waiting for IAM propagation..."
        sleep 10
    fi
    aws iam put-role-policy \
        --role-name "${ROLE_NAME}" \
        --policy-name "S3TablesDataAccess" \
        --policy-document "${S3_TABLES_POLICY}" >/dev/null
    echo -e "    ${CHECK} Done"

    # Step 2: LakeFormation admin
    echo ""
    echo -e "${ARROW} Adding caller as LakeFormation admin"
    aws lakeformation put-data-lake-settings \
        --data-lake-settings "{\"DataLakeAdmins\":[{\"DataLakePrincipalIdentifier\":\"${CALLER_ARN}\"}]}" \
        --region "${REGION}" 2>/dev/null || true
    echo -e "    ${CHECK} Done"

    # Step 3: Register resource
    echo ""
    echo -e "${ARROW} Registering S3 Tables resource with LakeFormation"
    local resource_arn="arn:aws:s3tables:${REGION}:${ACCOUNT_ID}:bucket/*"
    local role_arn="arn:aws:iam::${ACCOUNT_ID}:role/${ROLE_NAME}"

    aws lakeformation deregister-resource \
        --resource-arn "${resource_arn}" \
        --region "${REGION}" 2>/dev/null || true

    aws lakeformation register-resource \
        --resource-arn "${resource_arn}" \
        --role-arn "${role_arn}" \
        --with-federation \
        --region "${REGION}" 2>/dev/null || true
    echo -e "    ${CHECK} Done"

    # Step 4: Glue catalog
    echo ""
    echo -e "${ARROW} Creating/updating s3tablescatalog federated catalog"
    aws glue delete-catalog \
        --catalog-id "s3tablescatalog" \
        --region "${REGION}" 2>/dev/null || true

    aws glue create-catalog \
        --name "s3tablescatalog" \
        --catalog-input "{
            \"FederatedCatalog\": {
                \"Identifier\": \"${resource_arn}\",
                \"ConnectionName\": \"aws:s3tables\"
            },
            \"CreateDatabaseDefaultPermissions\": [],
            \"CreateTableDefaultPermissions\": [],
            \"CatalogProperties\": {
                \"CustomProperties\": {
                    \"AllowFullTableExternalDataAccess\": \"true\"
                }
            }
        }" \
        --region "${REGION}" 2>/dev/null || true
    echo -e "    ${CHECK} Done"

    # Step 5: Catalog permissions
    echo ""
    echo -e "${ARROW} Granting catalog permissions to caller"
    aws lakeformation grant-permissions \
        --principal "{\"DataLakePrincipalIdentifier\":\"${CALLER_ARN}\"}" \
        --resource "{\"Catalog\":{\"Id\":\"${ACCOUNT_ID}:s3tablescatalog\"}}" \
        --permissions "ALL" "DESCRIBE" "CREATE_DATABASE" "ALTER" "DROP" \
        --permissions-with-grant-option "ALL" "DESCRIBE" "CREATE_DATABASE" "ALTER" "DROP" \
        --region "${REGION}" 2>/dev/null || true
    echo -e "    ${CHECK} Done"
}

deploy_phase1() {
    echo ""
    echo "==> Phase 1: CloudFormation (table bucket, namespace, table, IAM role)"
    echo ""
    echo -e "${ARROW} Deploying CloudFormation stack: ${STACK}"

    aws cloudformation deploy \
        --template-file "${TEMPLATE}" \
        --stack-name "${STACK}" \
        --region "${REGION}" \
        --capabilities CAPABILITY_NAMED_IAM \
        --parameter-overrides "Phase=1" "TableBucketName=${BUCKET}" "NamespaceName=${NAMESPACE}" \
        --no-fail-on-empty-changeset

    echo -e "    ${CHECK} Phase 1 complete"
}

grant_lakeformation_permissions() {
    echo ""
    echo "==> Granting LakeFormation permissions to Firehose role"

    local role_arn
    role_arn=$(get_firehose_role_arn)

    if [ -z "$role_arn" ] || [ "$role_arn" = "None" ]; then
        echo -e "    ${CROSS} Could not find FirehoseRoleARN in stack outputs"
        exit 1
    fi

    echo "    Firehose role: ${role_arn}"

    echo ""
    echo -e "${ARROW} Granting DESCRIBE on database '${NAMESPACE}'"
    aws lakeformation grant-permissions \
        --region "${REGION}" \
        --principal "{\"DataLakePrincipalIdentifier\":\"${role_arn}\"}" \
        --resource "{\"Database\":{\"CatalogId\":\"${ACCOUNT_ID}:s3tablescatalog/${BUCKET}\",\"Name\":\"${NAMESPACE}\"}}" \
        --permissions DESCRIBE 2>/dev/null || true
    echo -e "    ${CHECK} Done"

    echo ""
    echo -e "${ARROW} Granting ALL on table 'logs'"
    aws lakeformation grant-permissions \
        --region "${REGION}" \
        --principal "{\"DataLakePrincipalIdentifier\":\"${role_arn}\"}" \
        --resource "{\"Table\":{\"CatalogId\":\"${ACCOUNT_ID}:s3tablescatalog/${BUCKET}\",\"DatabaseName\":\"${NAMESPACE}\",\"Name\":\"logs\"}}" \
        --permissions ALL 2>/dev/null || true
    echo -e "    ${CHECK} Done"

    echo ""
    echo -e "${ARROW} Granting ALL on table 'traces'"
    aws lakeformation grant-permissions \
        --region "${REGION}" \
        --principal "{\"DataLakePrincipalIdentifier\":\"${role_arn}\"}" \
        --resource "{\"Table\":{\"CatalogId\":\"${ACCOUNT_ID}:s3tablescatalog/${BUCKET}\",\"DatabaseName\":\"${NAMESPACE}\",\"Name\":\"traces\"}}" \
        --permissions ALL 2>/dev/null || true
    echo -e "    ${CHECK} Done"
}

deploy_phase2() {
    echo ""
    echo "==> Phase 2: CloudFormation (Firehose delivery stream)"
    echo ""
    echo -e "${ARROW} Updating CloudFormation stack: ${STACK}"

    aws cloudformation deploy \
        --template-file "${TEMPLATE}" \
        --stack-name "${STACK}" \
        --region "${REGION}" \
        --capabilities CAPABILITY_NAMED_IAM \
        --parameter-overrides "Phase=2" "TableBucketName=${BUCKET}" "NamespaceName=${NAMESPACE}" \
        --no-fail-on-empty-changeset

    echo -e "    ${CHECK} Phase 2 complete"
}

cmd_deploy() {
    if [ -z "$TEMPLATE" ]; then
        echo "Error: Template file is required for deploy"
        echo "Usage: $0 <template.yaml> --region <region> --stack <stack> --bucket <bucket>"
        exit 1
    fi

    if [ ! -f "$TEMPLATE" ]; then
        echo "Error: Template file not found: $TEMPLATE"
        exit 1
    fi

    echo "Deploying otlp2pipeline to AWS"
    echo ""
    get_account_info
    echo "Account:   ${ACCOUNT_ID}"
    echo "Region:    ${REGION}"
    echo "Stack:     ${STACK}"
    echo "Bucket:    ${BUCKET}"
    echo "Namespace: ${NAMESPACE}"
    echo "Template:  ${TEMPLATE}"

    # Phase 0: S3 Tables setup (always run for idempotency)
    setup_s3_tables

    # Check current stack state
    local current_phase=0
    if check_stack_exists; then
        current_phase=$(get_stack_phase)
    fi

    # Phase 1: Deploy infrastructure
    if [ "$current_phase" -lt 1 ]; then
        deploy_phase1
    else
        echo ""
        echo "==> Phase 1: Already complete (skipping)"
    fi

    # Grant LakeFormation permissions
    grant_lakeformation_permissions

    # Phase 2: Deploy Firehose
    if [ "$current_phase" -lt 2 ]; then
        deploy_phase2
    else
        echo ""
        echo "==> Phase 2: Already complete (skipping)"
    fi

    echo ""
    echo "=========================================="
    echo -e "${CHECK} Deployment complete!"
    echo "=========================================="
    echo ""
    echo "Test with:"
    echo "  ./scripts/aws-send-test-record.sh ${STACK} ${REGION}"
    echo ""
    echo "Check status:"
    echo "  $0 status --env ${ENV} --region ${REGION}"
}

# ============================================================================
# Destroy command
# ============================================================================

cmd_destroy() {
    echo "Destroying otlp2pipeline deployment"
    echo ""
    get_account_info
    echo "Account: ${ACCOUNT_ID}"
    echo "Region:  ${REGION}"
    echo "Stack:   ${STACK}"
    echo "Bucket:  ${BUCKET}"
    echo ""

    if [ "$FORCE" != true ]; then
        echo "This will delete:"
        echo "  - CloudFormation stack: ${STACK}"
        echo "  - S3 Table Bucket: ${BUCKET}"
        echo "  - All data in the bucket"
        echo ""
        read -p "Are you sure? (yes/no): " confirm
        if [ "$confirm" != "yes" ]; then
            echo "Aborted."
            exit 0
        fi
    fi

    # Delete CloudFormation stack
    if check_stack_exists; then
        echo ""
        echo -e "${ARROW} Deleting CloudFormation stack: ${STACK}"
        aws cloudformation delete-stack --stack-name "${STACK}" --region "${REGION}"
        echo "    Waiting for stack deletion..."
        aws cloudformation wait stack-delete-complete --stack-name "${STACK}" --region "${REGION}" 2>/dev/null || true
        echo -e "    ${CHECK} Stack deleted"
    else
        echo ""
        echo "    Stack does not exist (skipping)"
    fi

    echo ""
    echo "=========================================="
    echo -e "${CHECK} Destroy complete"
    echo "=========================================="
    echo ""
    echo "Note: The following global resources were NOT deleted:"
    echo "  - IAM Role: ${ROLE_NAME}"
    echo "  - Glue Catalog: s3tablescatalog"
    echo "  - LakeFormation configuration"
    echo ""
    echo "These are shared across stacks. Delete manually if no longer needed."
}

# ============================================================================
# Main
# ============================================================================

case "${COMMAND}" in
    status)
        cmd_status
        ;;
    destroy)
        cmd_destroy
        ;;
    *)
        cmd_deploy
        ;;
esac
