# @schema spans
# @description OTLP trace spans flattened for Cloudflare Streams
#
# timestamp: timestamp, required, "Start time in milliseconds"
# end_timestamp: int64, required, "End time in milliseconds"
# duration: int64, required, "Duration in milliseconds"
# trace_id: string, required, "Trace ID hex string"
# span_id: string, required, "Span ID hex string"
# parent_span_id: string, "Parent span ID hex string"
# trace_state: string, "W3C trace state"
# service_name: string, required, "Service name from resource attributes"
# service_namespace: string
# service_instance_id: string
# span_name: string, required, "Span operation name"
# span_kind: int32, required, "Span kind (0=unspecified, 1=internal, 2=server, 3=client, 4=producer, 5=consumer)"
# status_code: int32, required, "Status code (0=unset, 1=ok, 2=error)"
# status_message: string, "Status message for errors"
# resource_attributes: json, "Resource attributes blob"
# scope_name: string, "Instrumentation scope name"
# scope_version: string, "Instrumentation scope version"
# scope_attributes: json, "Scope attributes blob"
# span_attributes: json, "Span attributes blob"
# events_json: json, "Span events as JSON array"
# links_json: json, "Span links as JSON array"
# dropped_attributes_count: int32, "Number of dropped attributes"
# dropped_events_count: int32, "Number of dropped events"
# dropped_links_count: int32, "Number of dropped links"
# flags: int32, "Trace flags"
# @end

# vrl/otlp_traces.vrl
# OTLP traces -> flat trace event
# Uses custom WASM-compatible functions (not VRL stdlib)

# Convert nanoseconds to milliseconds (must be integer for schema)
.timestamp = to_int(.start_time_unix_nano) ?? 0
.timestamp = floor(.timestamp / 1000000) ?? 0

.end_timestamp = to_int(.end_time_unix_nano) ?? 0
.end_timestamp = floor(.end_timestamp / 1000000) ?? 0

# Duration in milliseconds (must be integer for schema)
.duration = to_int(.duration_ns) ?? 0
.duration = floor(.duration / 1000000) ?? 0

# Extract service info from resource attributes
# Use explicit null check since get() returns null for missing keys
.service_name_raw, err = get(.resource.attributes, ["service.name"])
if err != null || .service_name_raw == null {
    .service_name = "unknown"
} else {
    .service_name = .service_name_raw
}
.service_name_raw = null

.service_namespace = get(.resource.attributes, ["service.namespace"]) ?? null
.service_instance_id = get(.resource.attributes, ["service.instance.id"]) ?? null

# IDs - keep as strings, null if empty
.trace_id_str, err = to_string(.trace_id)
if err == null && .trace_id_str != "" {
    .trace_id = .trace_id_str
} else {
    .trace_id = null
}

.span_id_str, err = to_string(.span_id)
if err == null && .span_id_str != "" {
    .span_id = .span_id_str
} else {
    .span_id = null
}

.parent_span_id_str, err = to_string(.parent_span_id)
if err == null && .parent_span_id_str != "" {
    .parent_span_id = .parent_span_id_str
} else {
    .parent_span_id = null
}

# Span name
.span_name, err = to_string(.name)
if err != null {
    .span_name = ""
}

# Span kind (0=unspecified, 1=internal, 2=server, 3=client, 4=producer, 5=consumer)
if .kind == null {
    .span_kind = 0
} else {
    .span_kind = to_int(.kind) ?? 0
}

# Trace state
.trace_state_str, err = to_string(.trace_state)
if err == null && .trace_state_str != "" {
    .trace_state = .trace_state_str
} else {
    .trace_state = null
}

# Status
if .status_code == null {
    .status_code = 0
}

.status_message_str, err = to_string(.status_message)
if err == null && .status_message_str != "" {
    .status_message = .status_message_str
} else {
    .status_message = null
}

# Encode attribute blobs as JSON
if !is_empty(.resource.attributes) {
    .resource_attributes = encode_json(.resource.attributes)
} else {
    .resource_attributes = null
}

.scope_name_str, err = to_string(.scope.name)
if err == null && .scope_name_str != "" {
    .scope_name = .scope_name_str
} else {
    .scope_name = null
}

.scope_version_str, err = to_string(.scope.version)
if err == null && .scope_version_str != "" {
    .scope_version = .scope_version_str
} else {
    .scope_version = null
}

if !is_empty(.scope.attributes) {
    .scope_attributes = encode_json(.scope.attributes)
} else {
    .scope_attributes = null
}

if !is_empty(.attributes) {
    .span_attributes = encode_json(.attributes)
} else {
    .span_attributes = null
}

# Encode events as JSON array
if !is_empty(.events) {
    .events_json = encode_json(.events)
} else {
    .events_json = null
}

# Encode links as JSON array
if !is_empty(.links) {
    .links_json = encode_json(.links)
} else {
    .links_json = null
}

# Extract dropped counts and flags
.dropped_attributes_count = to_int(.dropped_attributes_count) ?? 0
.dropped_events_count = to_int(.dropped_events_count) ?? 0
.dropped_links_count = to_int(.dropped_links_count) ?? 0
.flags = to_int(.flags) ?? 0

# Clean up temporary and nested structures
.trace_id_str = null
.span_id_str = null
.parent_span_id_str = null
.trace_state_str = null
.status_message_str = null
.scope_name_str = null
.scope_version_str = null
.name = null
.kind = null
.start_time_unix_nano = null
.end_time_unix_nano = null
.duration_ns = null
.resource = null
.scope = null
.attributes = null
.events = null
.links = null

# Set routing table
._table = "traces"
